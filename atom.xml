<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>liusec&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://liusec.github.io/"/>
  <updated>2017-12-24T00:57:31.000Z</updated>
  <id>https://liusec.github.io/</id>
  
  <author>
    <name>liusec</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>编码转换</title>
    <link href="https://liusec.github.io/2017/12/24/%E7%BC%96%E7%A0%81%E8%BD%AC%E6%8D%A2/"/>
    <id>https://liusec.github.io/2017/12/24/编码转换/</id>
    <published>2017-12-24T00:48:08.000Z</published>
    <updated>2017-12-24T00:57:31.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x01-常见编码类型"><a href="#0x01-常见编码类型" class="headerlink" title="0x01 常见编码类型"></a>0x01 常见编码类型</h1><p>常见编码：</p><ul><li>ASCII</li><li>GBK</li><li>GB2312</li><li>UNICODE</li><li>UTF-8</li><li>UTF-16</li><li>url编码</li><li>hex编码</li><li>base64编码</li></ul><p>这篇文章不涉及url编码、hex编码、base64编码，后面有时间再补充。</p><h1 id="0x02-ASCII"><a href="#0x02-ASCII" class="headerlink" title="0x02 ASCII"></a>0x02 ASCII</h1><p>所有信息最终都是一个二进制值。每一个二进制位（bit）有0和1两种状态，因此八个二进制位就可以组合出256种状态，这被称为一个字节（byte）</p><p>一个字节一共可以用来表示256种不同的状态，每一个状态对应一个符号，就是256个符号，从00000000到11111111</p><p>上个世纪60年代，美国制定了一套字符编码，对英语字符与二进制位之间的关系，做了统一规定。这被称为 ASCII 码，一直沿用至今。</p><p>ASCII 码一共规定了128个字符的编码</p><p>这128个符号（包括32个不能打印出来的控制符号），只占用了一个字节的后面7位，最前面的一位统一规定为0。</p><p>ASCII 码表：</p><p><img src="/2017/12/24/编码转换/ASCII_Table.png" alt="编码转换/ASCII_Table.png"></p><p>python 显示 ASCII 码表（10进制 对应 字符表）:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; for i in range(0,128):</span><br><span class="line">...     print i,&apos; == &apos;,chr(i)</span><br></pre></td></tr></table></figure><h1 id="0x03-GBK"><a href="#0x03-GBK" class="headerlink" title="0x03 GBK"></a>0x03 GBK</h1><p>GB类的汉字编码与后文的 Unicode 和 UTF-8 是毫无关系的。</p><p>GBK是国家标准编码，它是对gb2312的扩展，定义了包含简体中文、繁体中文、日文、韩文等所用的字符。</p><p>在编码上，GBK采用了单双字节混合的方式：</p><ul><li>兼容ASCII，1个字节，范围为0x00~0x7F</li><li>对其它字符使用2个字节表示，但第一个字符最高位必须是1，即必须是0x80~0xFF。</li></ul><p>GB2312字符集包含了6763个简体汉字，和682个标准中文符号。每个汉字用2个字节表示，每个字节的ASCII码为161-254（16进制A1-FE），第一个字节对应于区码的1-94区，第二哥字节对应于位码的1-94位。</p><p><a href="http://tools.jb51.net/table/gb2312" target="_blank" rel="noopener">GB2312简体中文码表</a></p><h1 id="0x04-乱码"><a href="#0x04-乱码" class="headerlink" title="0x04 乱码"></a>0x04 乱码</h1><p>世界上存在着多种编码方式，同一个二进制数字可以被解释成不同的符号。因此，要想打开一个文本文件，就必须知道它的编码方式，否则用错误的编码方式解读，就会出现乱码。</p><p>如果有一种编码，将世界上所有的符号都纳入其中。每一个符号都给予一个独一无二的编码，那么乱码问题就会消失。这就是 Unicode，就像它的名字都表示的，这是一种所有符号的编码。</p><h1 id="0x05-UNICODE"><a href="#0x05-UNICODE" class="headerlink" title="0x05 UNICODE"></a>0x05 UNICODE</h1><p>可以容纳100多万个符号。每个符号的编码都不一样。</p><ul><li><p>比如，汉字严的 Unicode 是十六进制数4E25，转换成二进制数足足有15位（100111000100101），也就是说，这个符号的表示至少需要2个字节。</p></li><li><p>表示其他更大的符号，可能需要3个字节或者4个字节，甚至更多。</p></li></ul><p><a href="http://www.chi2ko.com/tool/CJK.htm" target="_blank" rel="noopener">中日韩汉字unicode编码表</a></p><p><strong>Unicode 只是一个符号集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储</strong>。</p><h2 id="存储问题"><a href="#存储问题" class="headerlink" title="存储问题"></a>存储问题</h2><p><strong>变化长度存储 or 固定长度存储</strong></p><ul><li><p>如果使用变化长度进行存储，怎么知道三个字节表示一个符号，而不是分别表示三个符号呢？</p></li><li><p>如果规定每个符号用三个或四个字节表示，英文字母存储是极大的浪费，文本文件的大小会因此大出二三倍。</p></li></ul><h2 id="多种存储方式"><a href="#多种存储方式" class="headerlink" title="多种存储方式"></a>多种存储方式</h2><p>为了实现unicode码在计算机上的二进制存储，出现了 Unicode 的多种存储方式</p><ul><li>UTF-8 是 Unicode 的实现方式之一(字符使用1～4个字节)</li><li>UTF-16（字符用两个字节或四个字节表示）</li><li>UTF-32（字符用四个字节表示）</li></ul><p><strong>说明</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UTF-16和UTF-32在互联网上基本不用。</span><br><span class="line">UTF-8 最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。</span><br></pre></td></tr></table></figure><h1 id="0x06-UTF-8-编码规则"><a href="#0x06-UTF-8-编码规则" class="headerlink" title="0x06 UTF-8 编码规则"></a>0x06 UTF-8 编码规则</h1><p>UTF-8 的编码规则很简单，只有二条：</p><ul><li>对于单字节的符号，字节的第一位设为0，后面7位为这个符号的 Unicode 码。因此对于英语字母，UTF-8 编码和 ASCII 码是相同的。</li><li>对于n字节的符号（n &gt; 1），第一个字节的前n位都设为1，第n + 1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的 Unicode 码。</li></ul><p>下表总结了编码规则，字母x表示可用编码的位。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Unicode符号范围      |         UTF-8编码方式</span><br><span class="line">(十六进制)           |           （二进制）</span><br><span class="line">--------------------+---------------------------------------------</span><br><span class="line">0000 0000-0000 007F | 0xxxxxxx</span><br><span class="line">0000 0080-0000 07FF | 110xxxxx 10xxxxxx</span><br><span class="line">0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx</span><br><span class="line">0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</span><br></pre></td></tr></table></figure><h1 id="0x07-BOM（Byte-Order-Mask）"><a href="#0x07-BOM（Byte-Order-Mask）" class="headerlink" title="0x07 BOM（Byte Order Mask）"></a>0x07 BOM（Byte Order Mask）</h1><ul><li><p>如果一个文本文件的头两个字节是FE FF，就表示该文件采用大头（大端法）方式；</p></li><li><p>如果一个文本文件的头两个字节是FF FE，就表示该文件采用小头（小端法）方式。</p></li></ul><p><strong>UTF-8文件的BOM“EF BB BF”，它实际上就是FE FF（大端法）用UTF-8编码而得到的。</strong></p><ul><li>FEFF 大端法，UTF-8表示为：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">FEFF在unicode与utf-8转化表中查询在第三行，使用3个字节表示</span><br><span class="line">1110  XXXX  10XX  XXXX  10XX  XXXX</span><br><span class="line"></span><br><span class="line">将FEFF填充进去后为：</span><br><span class="line">1110  1111  1011  1011  1011  1111</span><br><span class="line"></span><br><span class="line">十六进制表示即为：</span><br><span class="line">EF BB BF</span><br></pre></td></tr></table></figure><h1 id="0x08-编码测试"><a href="#0x08-编码测试" class="headerlink" title="0x08 编码测试"></a>0x08 编码测试</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#&apos;胜&apos;的unicode编码为u&apos;\u80dc&apos;</span><br><span class="line">&gt;&gt;&gt; a=u&apos;胜&apos;</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">u&apos;\u80dc&apos;</span><br><span class="line"></span><br><span class="line">#&apos;胜&apos;的gb2312编码为&apos;\xca\xa4&apos;</span><br><span class="line">&gt;&gt;&gt; b=a.encode(&apos;gb2312&apos;)</span><br><span class="line">&gt;&gt;&gt; b</span><br><span class="line">&apos;\xca\xa4&apos;</span><br><span class="line"></span><br><span class="line">#&apos;胜&apos;的gbk编码为&apos;\xca\xa4&apos;</span><br><span class="line">&gt;&gt;&gt; c=a.encode(&apos;gbk&apos;)</span><br><span class="line">&gt;&gt;&gt; c</span><br><span class="line">&apos;\xca\xa4&apos;</span><br><span class="line"></span><br><span class="line">#&apos;胜&apos;的utf-8编码为&apos;\xe8\x83\x9c&apos;</span><br><span class="line">&gt;&gt;&gt; d=a.encode(&apos;utf-8&apos;)</span><br><span class="line">&gt;&gt;&gt; d</span><br><span class="line">&apos;\xe8\x83\x9c&apos;</span><br><span class="line"></span><br><span class="line">#使用gb2312编码的&apos;胜&apos;，使用utf-8解码时为ʤ，本测试使用MAC系统，默认print解码方式为utf-8</span><br><span class="line">#之所以没有报错，是因为编码内容也符合utf-8的解读格式。</span><br><span class="line">#二进制为[11001010  10100100]，utf-8解码认为，第1个字节110开头且后面的字节10开头，表明是2个字节存储的，实际解读的unicode编码为 【1010100100】，为u&apos;\u02a4&apos;，所以utf-8解码后为ʤ</span><br><span class="line">#&gt;&gt;&gt; e=u&apos;\u02a4&apos;</span><br><span class="line">#&gt;&gt;&gt; print e</span><br><span class="line">#ʤ</span><br><span class="line">&gt;&gt;&gt; print b</span><br><span class="line">ʤ</span><br><span class="line"></span><br><span class="line">#使用gbk编码的&apos;胜&apos;，使用utf-8解码时为ʤ</span><br><span class="line">&gt;&gt;&gt; print c</span><br><span class="line">ʤ</span><br><span class="line"></span><br><span class="line">#使用utf-8编码的&apos;胜&apos;，使用utf-8解码时为&apos;胜&apos;</span><br><span class="line">&gt;&gt;&gt; print d</span><br><span class="line">胜</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><h1 id="0x09-编码绕过-SQL宽字节注入"><a href="#0x09-编码绕过-SQL宽字节注入" class="headerlink" title="0x09 编码绕过-SQL宽字节注入"></a>0x09 编码绕过-SQL宽字节注入</h1><p><code>宽字节注入</code> <code>gbk 解码</code> </p><p>php程序在开启<code>magic_quotes_gpc</code>或使用了addslashes()函数、或<code>mysql_[real_]escape_string()</code>函数对输入的特殊符号进行转义的情况下，针对字符型的输入，还有可能发生SQL注入。 </p><p>主要原因是用户输入的单引号(<code>&#39;</code>)会被自动加上反斜杠(<code>\</code>)进行转义，防止单引号的闭合导致SQL注入。但如果php程序中设置指定mysql连接使用<code>gbk</code>解码，则会导致宽字节注入。</p><p>比如，用户恶意输入<code>%df&#39;</code>,则php程序接收参数后，转义后为<code>%df\&#39;</code>，而<code>%df\</code>被<code>gbk</code>解码后为<code>運</code>字符,导致单引号<code>&#39;</code>转义失效。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a=urllib.unquote(&apos;%df&apos;)+&apos;\\&apos;</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">&apos;\xdf\\&apos;</span><br><span class="line">&gt;&gt;&gt; b=a.decode(&apos;utf-8&apos;)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">  File &quot;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/encodings/utf_8.py&quot;, line 16, in decode</span><br><span class="line">    return codecs.utf_8_decode(input, errors, True)</span><br><span class="line">UnicodeDecodeError: &apos;utf8&apos; codec can&apos;t decode byte 0xdf in position 0: invalid continuation byte</span><br><span class="line">&gt;&gt;&gt; b=a.decode(&apos;gbk&apos;)</span><br><span class="line">&gt;&gt;&gt; b</span><br><span class="line">u&apos;\u904b&apos;</span><br><span class="line">&gt;&gt;&gt; c=b.encode(&apos;utf-8&apos;)</span><br><span class="line">&gt;&gt;&gt; c</span><br><span class="line">&apos;\xe9\x81\x8b&apos;</span><br><span class="line">&gt;&gt;&gt; print c</span><br><span class="line">運</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><h1 id="0x10-iconv-转换字符集造成截断"><a href="#0x10-iconv-转换字符集造成截断" class="headerlink" title="0x10 iconv()转换字符集造成截断"></a>0x10 iconv()转换字符集造成截断</h1><p>php程序中iconv()函数说明：</p><p><code>string iconv ( string $in_charset , string $out_charset , string $str )</code></p><ul><li>in_charset：输入的字符集</li><li>out_charset：输出的字符集</li><li>str：要转换的字符串</li></ul><p>iconv在字符编码转换时可能导致字符串截断。当<code>$str</code>中有一个字符不能被目标字符集所表示时，<code>$str</code>从第一个无效字符开始截断并导致一个 E_NOTICE。</p><p>例如：$d = iconv(“UTF-8”, “gb2312”, $c);该代码是将变量$c从UTF-8编码转换为gb2312。那么当$c中存在一个不能被gb2312表示的字符时，那么就会截断。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$a = &quot;1.php&quot;;</span><br><span class="line">$b = &quot;.jpg&quot;;</span><br><span class="line">for($i=0; $i&lt;200; $i++)&#123;</span><br><span class="line">    $c = $a.chr($i).$b;</span><br><span class="line">    $d = iconv(&quot;UTF-8&quot;, &quot;gb2312&quot;, $c);</span><br><span class="line">    echo &quot;$i ==&gt; &quot;.$d.&quot;\n&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现当$i为128（0x80）时输出的字符串截断为1.php。</p><p>为什么从0x80开始截断，可以看utf8和gbk的编码范围。</p><blockquote><p>漏洞案例：</p></blockquote><p><a href="http://wooyun.chamd5.org/bug_detail.php?wybug_id=wooyun-2014-048293" target="_blank" rel="noopener">建站之星模糊测试实战之任意文件上传漏洞</a></p><h1 id="0x11-参考链接"><a href="#0x11-参考链接" class="headerlink" title="0x11 参考链接"></a>0x11 参考链接</h1><p><a href="http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html</a><br><a href="http://www.docin.com/p-178554948.html" target="_blank" rel="noopener">http://www.docin.com/p-178554948.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;0x01-常见编码类型&quot;&gt;&lt;a href=&quot;#0x01-常见编码类型&quot; class=&quot;headerlink&quot; title=&quot;0x01 常见编码类型&quot;&gt;&lt;/a&gt;0x01 常见编码类型&lt;/h1&gt;&lt;p&gt;常见编码：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ASCII&lt;/li&gt;
&lt;li&gt;
      
    
    </summary>
    
      <category term="安全开发" scheme="https://liusec.github.io/categories/%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91/"/>
    
      <category term="代码审计" scheme="https://liusec.github.io/categories/%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
    
      <category term="编码" scheme="https://liusec.github.io/tags/%E7%BC%96%E7%A0%81/"/>
    
      <category term="代码审计" scheme="https://liusec.github.io/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>使用Docker 部署 SRCMS</title>
    <link href="https://liusec.github.io/2017/12/08/%E4%BD%BF%E7%94%A8Docker%20%E9%83%A8%E7%BD%B2%20SRCMS/"/>
    <id>https://liusec.github.io/2017/12/08/使用Docker 部署 SRCMS/</id>
    <published>2017-12-08T14:16:08.000Z</published>
    <updated>2017-12-09T03:37:23.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-SRCMS-介绍"><a href="#0x01-SRCMS-介绍" class="headerlink" title="0x01 SRCMS 介绍"></a>0x01 SRCMS 介绍</h2><blockquote><p>SRCMS 是一款安全应急响应与缺陷管理软件，致力于为大、中、小企业和组织提供“最敏捷、安全和美观的安全应急响应中心的建站解决方案，帮助企业建立属于自己的安全应急响应中心和体系”。有了SRCMS，您就可以像使用Discuz!搭建论坛一样容易，为您的企业建立安全应急响应中心平台。</p><p>官网：</p><blockquote><p><a href="https://www.plusecurity.cn/srcms.html" target="_blank" rel="noopener">https://www.plusecurity.cn/srcms.html</a></p></blockquote><p>github地址：</p><blockquote><p><a href="https://github.com/martinzhou2015/SRCMS" target="_blank" rel="noopener">https://github.com/martinzhou2015/SRCMS</a></p></blockquote></blockquote><h2 id="0x02-构建-lamp-Dcokerfile"><a href="#0x02-构建-lamp-Dcokerfile" class="headerlink" title="0x02 构建 lamp Dcokerfile"></a>0x02 构建 lamp Dcokerfile</h2><p>首先，我们需要有构建一个lamp 运行环境。</p><blockquote><p>Dockerfile</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"># 基础镜像为ubuntu:14.04</span><br><span class="line">FROM ubuntu:14.04</span><br><span class="line"></span><br><span class="line"># 作者为liusec</span><br><span class="line">MAINTAINER liusec &lt;75065472@qq.com&gt;</span><br><span class="line"></span><br><span class="line"># 替换apt源: 将/etc/apt/sources.list文件中的archive.ubuntu.com替换为mirrors.aliyun.com</span><br><span class="line">RUN sed -i &apos;s/archive.ubuntu.com/mirrors.aliyun.com/g&apos; /etc/apt/sources.list</span><br><span class="line"></span><br><span class="line"># 设置环境变量: 将env环境变量中的TZ设置为Asia/Shanghai</span><br><span class="line">ENV TZ=Asia/Shanghai</span><br><span class="line"></span><br><span class="line"># (1)设置本地时间：强制为/usr/share/zoneinfo/Asia/Shanghai文件创建符号链接（软链接）为/etc/localtime，-f为force</span><br><span class="line"># (2)设置时区：向文件/etc/timezone中写入字符串‘Asia/Shanghai’,更改时区为上海</span><br><span class="line">RUN ln -snf /usr/share/zoneinfo/$TZ /etc/localtime &amp;&amp; echo $TZ &gt; /etc/timezone</span><br><span class="line"></span><br><span class="line"># 更新源</span><br><span class="line">RUN apt-get update -y</span><br><span class="line"></span><br><span class="line"># 安装apache、vim、bash-completion、unzip</span><br><span class="line">RUN apt-get install -y apache2 vim bash-completion unzip</span><br><span class="line"># 创建文件夹/var/lock/apache2 、/var/run/apache2</span><br><span class="line">RUN mkdir -p /var/lock/apache2 /var/run/apache2</span><br><span class="line"></span><br><span class="line"># 安装mysql-client、 mysql-server; 启动mysql服务; 设置mysql密码</span><br><span class="line">RUN apt-get install -y mysql-client mysql-server \</span><br><span class="line">    &amp;&amp; /etc/init.d/mysql start \</span><br><span class="line">    &amp;&amp; mysqladmin -u root password &quot;root&quot;</span><br><span class="line"></span><br><span class="line"># 安装php</span><br><span class="line">RUN apt-get install -y php5 php5-mysql php5-dev php5-gd php5-memcache php5-pspell php5-snmp snmp php5-xmlrpc libapache2-mod-php5 php5-cli</span><br><span class="line"># RUN yum install -y php php-mysql php-devel php-gd php-pecl-memcache php-pspell php-snmp php-xmlrpc php-xml</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 拷贝phpinfo.php 到docker镜像的/var/www/html/下</span><br><span class="line">COPY src/phpinfo.php /var/www/html/</span><br><span class="line"># 拷贝启动脚本start.sh 到docker镜像的根目录下</span><br><span class="line">COPY src/start.sh /start.sh</span><br><span class="line"># 增加启动脚本start.sh 所有用户和组的执行权限</span><br><span class="line">RUN chmod a+x /start.sh</span><br><span class="line"></span><br><span class="line"># 只开放了80 443端口的映射访问权限</span><br><span class="line">EXPOSE 80 443</span><br><span class="line"># 运行后默认执行start.sh启动脚本</span><br><span class="line">CMD [&quot;/start.sh&quot;]</span><br></pre></td></tr></table></figure><blockquote><p>src/start.sh</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">/etc/init.d/mysql start</span><br><span class="line">/etc/init.d/apache2 restart</span><br><span class="line">/usr/bin/tail -f /dev/null</span><br></pre></td></tr></table></figure><blockquote><p>src/phpinfo.php</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">phpinfo();</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><h2 id="0x03-生成镜像，启动容器"><a href="#0x03-生成镜像，启动容器" class="headerlink" title="0x03 生成镜像，启动容器"></a>0x03 生成镜像，启动容器</h2><h3 id="3-1-在daocloud云端构建和启动容器"><a href="#3-1-在daocloud云端构建和启动容器" class="headerlink" title="3.1 在daocloud云端构建和启动容器"></a>3.1 在daocloud云端构建和启动容器</h3><p>将上述文件push到github项目中，lamp项目地址：</p><p><a href="https://github.com/liusec/lamp" target="_blank" rel="noopener">https://github.com/liusec/lamp</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">├── Dcokerfile</span><br><span class="line">├── README.md</span><br><span class="line">└── src</span><br><span class="line">    ├── phpinfo.php</span><br><span class="line">    └── start.sh</span><br><span class="line"></span><br><span class="line">1 directory, 4 files</span><br></pre></td></tr></table></figure><p>使用daocloud 关联github，自动构建lamp镜像，使用构建好的镜像启动容器进行测试。</p><p>daocloud 云端测试截图：</p><p><img src="http://p0naohs8x.bkt.clouddn.com/phpinfo.png" alt="phpinfo.png"></p><h3 id="3-2-本地启动lamp容器测试"><a href="#3-2-本地启动lamp容器测试" class="headerlink" title="3.2 本地启动lamp容器测试"></a>3.2 本地启动lamp容器测试</h3><p>构建好的docker镜像已设置公开访问，希望在本地测试的小伙伴可以使用下面方法。</p><ol><li><p>拉取镜像到本地</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker pull daocloud.io/liusheng/lamp:master-98827dc</span><br></pre></td></tr></table></figure></li><li><p>启动环境</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d -p 8000:80 daocloud.io/liusheng/srcms_docker:latest</span><br></pre></td></tr></table></figure><blockquote><p><code>-p 8000:80</code> 前面的 8000 代表物理机的端口，可随意指定。</p></blockquote></li><li><p>访问测试</p><p><a href="http://127.0.0.1:8000/phpinfo.php" target="_blank" rel="noopener">http://127.0.0.1:8000/phpinfo.php</a></p></li></ol><h2 id="0x04-创建srcms-docker-image"><a href="#0x04-创建srcms-docker-image" class="headerlink" title="0x04 创建srcms docker image"></a>0x04 创建srcms docker image</h2><p>在上一步lamp镜像的基础上，创建srcms的Dockerfile</p><blockquote><p>Dockerfile</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"># 基础镜像为daocloud.io/liusheng/lamp</span><br><span class="line">FROM daocloud.io/liusheng/lamp:master-98827dc</span><br><span class="line"></span><br><span class="line"># 作者为liusec</span><br><span class="line">MAINTAINER liusec &lt;75065472@qq.com&gt;</span><br><span class="line"></span><br><span class="line">ARG SRCMS_URL=https://github.com/martinzhou2015/SRCMS/archive/master.zip</span><br><span class="line"></span><br><span class="line"># 解压srcms.zip 到 /var/www/html/下</span><br><span class="line">RUN set -x \</span><br><span class="line">    &amp;&amp; apt-get update \</span><br><span class="line">    &amp;&amp; apt-get install -y --force-yes wget \</span><br><span class="line">    &amp;&amp; wget -qO /tmp/srcms.zip $SRCMS_URL \</span><br><span class="line">    &amp;&amp; unzip -q /tmp/srcms.zip -d /tmp/ \</span><br><span class="line">    &amp;&amp; mv /tmp/SRCMS-master/* /var/www/html/ \</span><br><span class="line">    &amp;&amp; rm -rf /tmp/SRCMS-master</span><br><span class="line"></span><br><span class="line"># 创建数据库srcms ，导入sql</span><br><span class="line"># 修改接收邮件的邮箱</span><br><span class="line">RUN set -x \</span><br><span class="line">    &amp;&amp; chown -R www-data:www-data /var/www/html/ \</span><br><span class="line">    &amp;&amp; /etc/init.d/mysql start \</span><br><span class="line">    &amp;&amp; mysql -e &quot;CREATE DATABASE srcms DEFAULT CHARACTER SET utf8;&quot; -uroot -proot \</span><br><span class="line">    &amp;&amp; mysql -e &quot;use srcms;source /var/www/html/DB/srcms.sql;&quot; -uroot -proot \</span><br><span class="line">    &amp;&amp; rm -f /var/www/html/DB/srcms.sql \</span><br><span class="line">    &amp;&amp; sed -i &apos;s/1009465756@qq.com/75065472@qq.com/g&apos; /var/www/html/Application/User/Controller/PostController.class.php</span><br><span class="line"></span><br><span class="line">COPY src/start.sh /start.sh</span><br><span class="line">RUN chmod a+x /start.sh</span><br><span class="line"></span><br><span class="line">EXPOSE 80</span><br></pre></td></tr></table></figure><blockquote><p>src/start.sh</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">/etc/init.d/mysql restart</span><br><span class="line">/etc/init.d/apache2 restart</span><br><span class="line">/usr/bin/tail -f /dev/null</span><br></pre></td></tr></table></figure><h2 id="0x05-生成镜像，启动运行"><a href="#0x05-生成镜像，启动运行" class="headerlink" title="0x05 生成镜像，启动运行"></a>0x05 生成镜像，启动运行</h2><h3 id="5-1-在云端启动docker容器"><a href="#5-1-在云端启动docker容器" class="headerlink" title="5.1 在云端启动docker容器"></a>5.1 在云端启动docker容器</h3><p>将上面所述文件push到github项目,srcms_docker项目地址：</p><p><a href="https://github.com/liusec/srcms_docker" target="_blank" rel="noopener">https://github.com/liusec/srcms_docker</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">├── Dockerfile</span><br><span class="line">├── README.md</span><br><span class="line">└── src</span><br><span class="line">    └── start.sh</span><br><span class="line"></span><br><span class="line">1 directory, 3 files</span><br></pre></td></tr></table></figure><p>使用daocloud 自动构建，启动服务</p><p><img src="http://p0naohs8x.bkt.clouddn.com/srcms_index.png" alt="srcms_index.png"></p><h3 id="5-2-在本地启动docker容器"><a href="#5-2-在本地启动docker容器" class="headerlink" title="5.2 在本地启动docker容器"></a>5.2 在本地启动docker容器</h3><p>希望在本地部署的小伙伴可以将docker镜像拉取到本地启动，方法如下</p><ol><li><p>拉取镜像到本地</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker pull daocloud.io/liusheng/srcms_docker:latest</span><br></pre></td></tr></table></figure></li><li><p>启动环境</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d -p 8000:80 daocloud.io/liusheng/srcms_docker:latest</span><br></pre></td></tr></table></figure><blockquote><p><code>-p 8000:80</code> 前面的 8000 代表物理机的端口，可随意指定。 </p></blockquote></li><li><p>访问SRCMS</p><p><a href="http://127.0.0.1:8000/index.php" target="_blank" rel="noopener">http://127.0.0.1:8000/index.php</a></p><p><img src="http://p0naohs8x.bkt.clouddn.com/srcms_index.png" alt="srcms_index.png"></p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x01-SRCMS-介绍&quot;&gt;&lt;a href=&quot;#0x01-SRCMS-介绍&quot; class=&quot;headerlink&quot; title=&quot;0x01 SRCMS 介绍&quot;&gt;&lt;/a&gt;0x01 SRCMS 介绍&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;SRCMS 是一款安全应急
      
    
    </summary>
    
      <category term="安全开发" scheme="https://liusec.github.io/categories/%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="docker" scheme="https://liusec.github.io/tags/docker/"/>
    
      <category term="srcms" scheme="https://liusec.github.io/tags/srcms/"/>
    
  </entry>
  
</feed>
